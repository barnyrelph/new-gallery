<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>gallery-js&#x2F;datatable-selection.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/PickList.html">PickList</a></li>
            
                <li><a href="..&#x2F;classes/Y.Calendar.JumpNavView.html">Y.Calendar.JumpNavView</a></li>
            
                <li><a href="..&#x2F;classes/Y.ContextMenuView.html">Y.ContextMenuView</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.BaseCellInlineEditor.html">Y.DataTable.BaseCellInlineEditor</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.BaseCellPopupEditor.html">Y.DataTable.BaseCellPopupEditor</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.CheckboxSelect.html">Y.DataTable.CheckboxSelect</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.Editable.html">Y.DataTable.Editable</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.html">Y.DataTable.EditorOptions</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.autocomplete.html">Y.DataTable.EditorOptions.autocomplete</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.calendar.html">Y.DataTable.EditorOptions.calendar</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.checkbox.html">Y.DataTable.EditorOptions.checkbox</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.date.html">Y.DataTable.EditorOptions.date</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.dropdown.html">Y.DataTable.EditorOptions.dropdown</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.inline.html">Y.DataTable.EditorOptions.inline</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.inlineAC.html">Y.DataTable.EditorOptions.inlineAC</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.inlineDate.html">Y.DataTable.EditorOptions.inlineDate</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.inlineNumber.html">Y.DataTable.EditorOptions.inlineNumber</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.number.html">Y.DataTable.EditorOptions.number</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.radio.html">Y.DataTable.EditorOptions.radio</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.text.html">Y.DataTable.EditorOptions.text</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.textarea.html">Y.DataTable.EditorOptions.textarea</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.Formatters.html">Y.DataTable.Formatters</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.Paginator.html">Y.DataTable.Paginator</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.Selection.html">Y.DataTable.Selection</a></li>
            
                <li><a href="..&#x2F;classes/Y.FooterView.html">Y.FooterView</a></li>
            
                <li><a href="..&#x2F;classes/Y.PaginatorModel.html">Y.PaginatorModel</a></li>
            
                <li><a href="..&#x2F;classes/Y.PaginatorView.html">Y.PaginatorView</a></li>
            
                <li><a href="..&#x2F;classes/Y.Plugin.Calendar.JumpNav.html">Y.Plugin.Calendar.JumpNav</a></li>
            
                <li><a href="..&#x2F;classes/Y.Plugin.DataTableContextMenu.html">Y.Plugin.DataTableContextMenu</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/DataTable.html">DataTable</a></li>
            
                <li><a href="..&#x2F;modules/FooterView.html">FooterView</a></li>
            
                <li><a href="..&#x2F;modules/gallery-contextmenu-view.html">gallery-contextmenu-view</a></li>
            
                <li><a href="..&#x2F;modules/gallery-datatable-celleditor-inline.html">gallery-datatable-celleditor-inline</a></li>
            
                <li><a href="..&#x2F;modules/gallery-datatable-celleditor-popup.html">gallery-datatable-celleditor-popup</a></li>
            
                <li><a href="..&#x2F;modules/gallery-datatable-contextmenu.html">gallery-datatable-contextmenu</a></li>
            
                <li><a href="..&#x2F;modules/gallery-datatable-editable.html">gallery-datatable-editable</a></li>
            
                <li><a href="..&#x2F;modules/gallery-datatable-formatters.html">gallery-datatable-formatters</a></li>
            
                <li><a href="..&#x2F;modules/gallery-datatable-paginator.html">gallery-datatable-paginator</a></li>
            
                <li><a href="..&#x2F;modules/gallery-datatable-selection.html">gallery-datatable-selection</a></li>
            
                <li><a href="..&#x2F;modules/gallery-paginator-view.html">gallery-paginator-view</a></li>
            
                <li><a href="..&#x2F;modules/gallery-picklist.html">gallery-picklist</a></li>
            
                <li><a href="..&#x2F;modules/Selection.html">Selection</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: gallery-js&#x2F;datatable-selection.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 A class extension for DataTable that adds &quot;highlight&quot; and &quot;select&quot; actions via mouse selection.
 The extension works in either &quot;cell&quot; mode or &quot;row&quot; mode (set via attribute [selectionMode](#attr_selectionMode)).

 Highlighting is controlled by the [highlightMode](#attr_highlightMode) attribute (either &quot;cell&quot; or &quot;row&quot;).
 (Highlighting provides a &quot;mouseover&quot; indication only), and a delegated &quot;mouseover&quot; event is defined in this module.

 Selection is provided via &quot;click&quot; listeners, by setting a delegated &quot;click&quot; handler on the TD or TR elements.

 This extension includes the ability to select &quot;multiple&quot; items, by setting the [selectionMulti](#attr_selectionMulti)
 attribute (enabled using browser multi-select click modifier, i.e. &quot;Cmd&quot; key on Mac OSX or &quot;Ctrl&quot; key on Windows &#x2F; Linux).

 Additionally, a &quot;range&quot; selection capability is provided by using the browser range selector click key modifier,
 specifically the Shift key on most systems.

 The extension has been written to allow preserving the &quot;selected&quot; rows or cells during &quot;sort&quot; operations.  This is
 accomplished by storing the selected TR&#x27;s basis record, specifically the &quot;clientId&quot; attribute which remains unique
 after sorting operations.

 Specific attributes are provided that can be read for current selections, including the ATTRS [selectedRows](#attr_selectedRows),
 and [selectedCells](#attr_selectedCells).

 Typical usage would be to set the &quot;selectionMode&quot; and &quot;highlightMode&quot; attributes (and selectionMulti if desired) and then
 to provide a positive control (like a BUTTON or A link) to process the selections.  Two events are provided,  [selection](#event_selection)
 and [selected](#event_selected) but these fire for every &quot;click&quot; action, which may not be ideal -- especially for multi selections.

 @module gallery-datatable-selection
 @class Y.DataTable.Selection
 @extends Y.DataTable
 @author Todd Smith
 @since 3.6.0
 **&#x2F;
function DtSelection() {}

DtSelection.ATTRS = {
    &#x2F;**
     * Node for the most recent &quot;highlighted&quot; item, either TD or TR
     * @attribute highlighted
     * @type {Node}
     * @default null
     *&#x2F;
    highlighted : {
        value:      null,
        validator:  function(v){ return (v instanceof Y.Node) || v === null; }
    },

    &#x2F;**
     * Node for the most recent &quot;selected&quot; item, either TD or TR
     * @attribute selected
     * @type {Node}
     * @default null
     *&#x2F;
    selected:{
        value:      null,
        validator:  function(v){ return (v instanceof Y.Node) || v === null; }
    },

    &#x2F;**
     * Set the current mode for highlighting, either for a single TD (as &quot;cell&quot;) or for a
     * full TR (as &quot;row&quot;) or &quot;none&quot; for no highlighting
     * @attribute highlightMode
     * @type {String}
     * @default &#x27;none&#x27;
     *&#x2F;
    highlightMode:{
        value:      &#x27;none&#x27;,
        setter:     &#x27;_setHighlightMode&#x27;,
        validator:  function(v){
            if (!Y.Lang.isString(v)) {
                return false;
            }
            return (v === &#x27;none&#x27; || v === &#x27;cell&#x27; || v ===&#x27;row&#x27; ) ? true : false;
        }
    },

    &#x2F;**
     * Set the current mode for indicating selections, either for a single TD (as &quot;cell&quot;) or for a
     * full TR (as &quot;row&quot;) or &#x27;none&#x27; for no selection
     *
     * @attribute selectionMode
     * @type {String}
     * @default &#x27;none&#x27;
     *&#x2F;
    selectionMode:{
        value:      &#x27;none&#x27;,
        setter:     &#x27;_setSelectionMode&#x27;,
        validator:  function(v){
            if (!Y.Lang.isString(v)) {
                return false;
            }
            return (v === &#x27;none&#x27; || v === &#x27;cell&#x27; || v ===&#x27;row&#x27; ) ? true : false;
        }
    },

    &#x2F;**
     * Attribute that holds the selected TR&#x27;s associated with either the selected &quot;rows&quot; or the
     *  TR&#x27;s that are related to the selected &quot;cells&quot;, duplicates are excluded.
     *
     * On input, accepts an Array of record indices for rows that should be set as &quot;selected&quot;.
     * (Please refer to method [_setSelectedRows](#method__setSelectedRows))
     *
     *          dt.set(&#x27;selectedRows&#x27;,[ 1, 5, 9, 11]);
     *          &#x2F;&#x2F; selects the 2nd, 6th, 10th and 12th records
     *
     * For reading this setting, it returns an Array of objects containing {tr,record,recordIndex} for each
     *  selected &quot;row&quot;; where &quot;tr&quot; is a Y.Node instance and &quot;record&quot; is the Model for the TR and &quot;recordIndex&quot; is the
     *  record index within the current dataset.
     * (Please refer to method [_getSelectedRows](#method__getSelectedRows))
     *
     * @attribute selectedRows
     * @type {Array}
     * @default []
     *&#x2F;
    selectedRows: {
        value:      [],
        validator:  Y.Lang.isArray,
        getter:     &#x27;_getSelectedRows&#x27;,
        setter:     &#x27;_setSelectedRows&#x27;
    },

    &#x2F;**
     * Attribute that holds the selected TD&#x27;s associated with the selected &quot;cells&quot;, or related to the
     *  selected &quot;rows&quot; if that is the &#x60;selectionMode&#x60;.
     *
     *  On input, an Array can be provided to pre-set as &quot;selected&quot; cells, defined as each element being
     *  in {record,column} format; where &quot;record&quot; is the record index (or clientId) and &quot;column&quot; is either
     *  the column index or the key&#x2F;name for the column.
     *  (Please see method [_setSelectedCells](#method__setSelectedCells) for reference).
     *
     *          dt.set(&#x27;selectedCells&#x27;,[{record:0,column:&#x27;fname&#x27;}, {record:187,column:7} ]);
     *
     *  For reading the selected cells (via &quot;get&quot;), an array is returned with contains {Object} elements
     *  that describe the row &#x2F; column combinations of each currently selected cell.
     *  (Please see method [_getSelectedCells](#method__getSelectedCells) for full information on the returned objects).
     *
     * @attribute selectedCells
     * @type {Array}
     * @default []
     *&#x2F;
    selectedCells: {
        value:      [],
        validator:  Y.Lang.isArray,
        setter:     &#x27;_setSelectedCells&#x27;,
        getter:     &#x27;_getSelectedCells&#x27;
    },

    &#x2F;**
     * Flag to allow either single &quot;selections&quot; (false) or multiple selections (true).
     * For Macintosh OSX-type systems the modifier key &quot;Cmd&quot; is held for multiple selections,
     *  and for Windows or Linux type systems the modifier key is &quot;Ctrl&quot;.
     *
     * @attribute selectionMulti
     * @type {Boolean}
     * @default false
     *&#x2F;
    selectionMulti: {
        value:      false,
        validator:  Y.Lang.isBoolean
    }

};


Y.mix( DtSelection.prototype, {

    &#x2F;**
     * @property _selections
     * @type Array
     * @default null
     * @static
     * @protected
     *&#x2F;
    _selections: null,

    &#x2F;**
     * Holder for the classname for the &quot;highlight&quot; TR or TD
     * @property _classHighlight
     * @type String
     * @default null
     * @static
     * @protected
     *&#x2F;
    _classHighlight: null,

    &#x2F;**
     * Holder for the classname for the &quot;selected&quot; TR or TD
     * @property _classSelected
     * @type String
     * @default null
     * @static
     * @protected
     *&#x2F;
    _classSelected: null,

    &#x2F;**
     * Holder for the most recent &quot;click&quot; event modifier keys from last click,
     *  used for assessing &quot;multi&quot; selections.
     *
     * Contains properties;  altKey, ctrlKey, shiftKey, metaKey, button and which
     *
     * Filled initially by .initializer and on each Table &quot;click&quot;.
     *
     * @property _clickModifiers
     * @type Object
     * @default null
     * @static
     * @protected
     *&#x2F;
    _clickModifiers: null,

    &#x2F;**
     * Holder for the event subscription handles so that this compoent can be destroyed
     *  by removing listeners
     *
     * @property _subscrSelectComp
     * @type Array of EventHandles
     * @default null
     * @static
     * @protected
     *&#x2F;
    _subscrSelectComp : null,

    &#x2F;**
     * Holder for the event subscription handles so that this compoent can be destroyed
     *  by removing listeners
     *
     * @property _subscrSelect
     * @type EventHandle
     * @default null
     * @static
     * @protected
     *&#x2F;
    _subscrSelect : null,

    &#x2F;**
     * Holder for the event subscription handles so that this compoent can be destroyed
     *  by removing listeners
     *
     * @property _subscrHighlight
     * @type EventHandle
     * @default null
     * @static
     * @protected
     *&#x2F;
    _subscrHighlight : null,


&#x2F;&#x2F;------------------------------------------------------------------------------------------------------
&#x2F;&#x2F;        L I F E C Y C L E    M E T H O D S
&#x2F;&#x2F;------------------------------------------------------------------------------------------------------

    &#x2F;**
     * Initializes and sets initial bindings for the datatable-selection module
     * @method initializer
     * @protected
     *&#x2F;
    initializer: function(){
        this._bindSelector();
    },

    &#x2F;**
     * Destructor to clean up bindings.
     * @method destructor
     * @protected
     *&#x2F;
    destructor: function () {
        this._unbindSelector();
    },



&#x2F;&#x2F;------------------------------------------------------------------------------------------------------
&#x2F;&#x2F;        P U B L I C     M E T H O D S
&#x2F;&#x2F;------------------------------------------------------------------------------------------------------

    &#x2F;**
     * Method to enable the datatable-selection module
     * @method disableSelection
     * @public
     *&#x2F;
    enableSelection: function(){
        this.disableSelection();
        this._bindSelector();
    },

    &#x2F;**
     * Method to disable the datatable-selection module (cleans up listeners and user interface).
     * @method disableSelection
     * @public
     *&#x2F;
    disableSelection: function(){
        this.clearAll();
        this._unbindSelector();
    },

    &#x2F;**
     * Returns the Column object (from the original &quot;columns&quot;) associated with the input TD Node.
     * @method getColumnByTd
     * @param {Node} cell Node of TD for which column object is desired
     * @return {Object} column The column object entry associated with the desired cell
     * @public
     *&#x2F;
    getColumnByTd:  function(cell){
        var colName = this.getColumnNameByTd(cell);
        return (colName) ? this.getColumn(colName) : null;
    },


    &#x2F;**
     * Returns the column &quot;key&quot; or &quot;name&quot; string for the requested TD Node
     * @method getColumnNameByTd
     * @param {Node} cell Node of TD for which column name is desired
     * @return {String} colName Column name or key name
     * @public
     *&#x2F;
    getColumnNameByTd: function(cell){
        var classes = cell.get(&#x27;className&#x27;).split(&quot; &quot;),
            regCol  = new RegExp( this.getClassName(&#x27;col&#x27;) + &#x27;-(.*)&#x27;),
            colName;

        Y.Array.some(classes,function(item) {
            var colmatch =  item.match(regCol);
            if ( colmatch &amp;&amp; Y.Lang.isArray(colmatch) &amp;&amp; colmatch[1] ) {
                colName = colmatch[1];
                return true;
            }
        });

        return colName || null;
    },

    &#x2F;**
     * Removes all &quot;selected&quot; classes from DataTable and resets internal selections counters and &quot;selected&quot; attribute.
     * @method clearSelections
     * @public
     *&#x2F;
    clearSelections: function(){
        this._selections = [];
        this.set(&#x27;selected&#x27;,null);
        this._clearAll(this._classSelected);
    },

    &#x2F;**
     * Removes all &quot;highlight&quot; classes from DataTable and resets &#x60;highlighted&#x60; attribute.
     * @method clearHighlighted
     * @public
     *&#x2F;
    clearHighlighted: function(){
        this.set(&#x27;highlighted&#x27;,null);
        this._clearAll(this._classHighlight);
    },

    &#x2F;**
     * Removes all highlighting and selections on the DataTable.
     * @method clearAll
     * @public
     *&#x2F;
    clearAll: function(){
        this.clearSelections();
        this.clearHighlighted();
    },

&#x2F;&#x2F;------------------------------------------------------------------------------------------------------
&#x2F;&#x2F;        P R I V A T E    M E T H O D S
&#x2F;&#x2F;------------------------------------------------------------------------------------------------------

    &#x2F;**
     * Sets listeners and initial class names required for this &quot;datatable-selector&quot; module
     *
     * Note:  Delegated &quot;click&quot; listeners are defined in _setSelectedMode and _setHightlightMode methods
     *
     * @method _bindSelector
     * @private
     *&#x2F;
    _bindSelector: function(){
        this._selections = [];
        this._subscrSelectComp = [];

        this._subscrSelectComp.push( this.on(&#x27;highlightedChange&#x27;,this._highlightChange) );
        this._subscrSelectComp.push( this.on(&#x27;selectedChange&#x27;,this._selectedChange) );

        &#x2F;&#x2F; set CSS classes for highlighting and selected,
        &#x2F;&#x2F;    currently as  &quot;.yui3-datatable-sel-highlighted&quot; and &quot;.yui3-datatable-sel-selected&quot;
        this._classHighlight = this.getClassName(&#x27;sel&#x27;,&#x27;highlighted&#x27;);
        this._classSelected  = this.getClassName(&#x27;sel&#x27;,&#x27;selected&#x27;);

        &#x2F;&#x2F;
        &#x2F;&#x2F;  These listeners are here solely for &quot;sort&quot; actions, to allow preserving the &quot;selections&quot;
        &#x2F;&#x2F;   pre-sort and re-applying them after the TBODY has been sorted and displayed
        &#x2F;&#x2F;
    &#x2F;&#x2F;    this._subscrSelectComp.push( this.before(&#x27;sort&#x27;, this._beforeResetDataSelect) );
        this._subscrSelectComp.push( this.after(&#x27;sort&#x27;, this._afterResetDataSelect) );
    &#x2F;&#x2F;        this._subscrSelectComp.push( this.data.before(&#x27;*:reset&#x27;, Y.bind(&#x27;_beforeResetDataSelect&#x27;, this) ) );
    &#x2F;&#x2F;        this._subscrSelectComp.push( this.data.after(&#x27;*:reset&#x27;, Y.bind(&#x27;_afterResetDataSelect&#x27;, this) ) );

        &#x2F;&#x2F; track click modifier keys from last click, this is the tempalte
        this._clickModifiers = {
            ctrlKey:null, altKey:null, metaKey:null, shiftKey:null, which:null, button:null
        };
    },

    &#x2F;**
     * Cleans up listener event handlers and static properties.
     * @method _unbindSelector
     * @private
     *&#x2F;
    _unbindSelector: function(){

        &#x2F;&#x2F; clear all current visual UI settings
        this._clearAll(this._classHighlight);
        this._clearAll(this._classSelected);

        &#x2F;&#x2F; detach listener on DT &quot;click&quot; event
        if ( this._subscrSelect &amp;&amp; this._subscrSelect.detach ) {
            this._subscrSelect.detach();
        }
        this._subscrSelect = null;

        &#x2F;&#x2F; detach listener on DT &quot;mouseenter&quot; event
        if ( this._subscrHighlight &amp;&amp; this._subscrHighlight.detach ) {
            this._subscrHighlight.detach();
        }
        this._subscrHighlight = null;

        &#x2F;&#x2F; clear up other listeners set in bindSelector ...
        if ( this._subscrHighlight
            &amp;&amp; this._subscrHighlight.detach ) {
                this._subscrHighlight.detach();
        }
        this._subscrHighlight = null;

        &#x2F;&#x2F; Clear up the overall component listeners (array)
        Y.Array.each( this._subscrSelectComp,function(item){
            if (!item) {
                return;
            }

            if(Y.Lang.isArray(item)) {
                Y.Array.each(item,function(si){
                    si.detach();
                });
            } else if (item.detach) {
                item.detach();
            }
        });
        this._subscrSelectComp = null;

        &#x2F;&#x2F; clean up static props set
        this._clickModifiers = null;
        this._selections = null;
        this._classHighlight = null;
        this._classSelected  = null;

    },

    &#x2F;**
     * Method that updates the &quot;highlighted&quot; classes for the selection and unhighlights the prevVal
     * @method _highlightChange
     * @param o
     * @private
     *&#x2F;
    _highlightChange: function(o) {
        this._processNodeAction(o,&#x27;highlight&#x27;,true);
        return;
    },

    &#x2F;**
     * Method that updates the &quot;selected&quot; classes for the selection and un-selects the prevVal.
     * This method works with multiple selections (via ATTR &#x60;selectionMulti&#x60; true) by pushing
     * the current selection to the this._selections property.
     *
     * @method _selectedChange
     * @param o
     * @private
     *&#x2F;
    _selectedChange: function(o){
        &#x2F;&#x2F; Evaluate a flag to determine whether previous selections should be cleared or &quot;kept&quot;
        var keepPrev, keepRange, tar, sobj;

        if ( Y.UA.os.search(&#x27;macintosh&#x27;) === 0 ) {
            keepPrev =  this.get(&#x27;selectionMulti&#x27;) === true &amp;&amp; this._clickModifiers.metaKey === true;
        } else {
            keepPrev =  this.get(&#x27;selectionMulti&#x27;) === true &amp;&amp; this._clickModifiers.ctrlKey === true;
        }

        keepRange = this.get(&#x27;selectionMulti&#x27;) === true &amp;&amp; this._clickModifiers.shiftKey === true;

        &#x2F;&#x2F; clear any SHIFT selected text first ...
        this._clearDOMSelection();

        &#x2F;&#x2F; if not-multi mode and more than one selection, clear them first ...
        if ( !keepPrev &amp;&amp; !keepRange &amp;&amp; this._selections.length&gt;1 ) {
            this.clearSelections();
        }

        if ( keepRange ) {

            this._processRange(o);

        }  else {

            &#x2F;&#x2F; Process the action ... updating &#x27;select&#x27; class
            tar = this._processNodeAction(o,&#x27;select&#x27;, !keepPrev );

            if ( !keepPrev ) {
                this._selections = [];
            }

            if(this.get(&#x27;selectionMode&#x27;)===&#x27;row&#x27;) {
                this._selections.push( this._selectTr(tar) );
            } else {
                this._selections.push( this._selectTd(tar) );
            }

        }

        this.fire(&#x27;selected&#x27;,{
            ochange: o,
            record: this.getRecord(o.newVal)
        });

        &#x2F;&#x2F;
        &#x2F;&#x2F;  Fire a generic &quot;selection&quot; event that returns selected data according to the current &quot;selectionMode&quot; setting
        &#x2F;&#x2F;
        sobj = { selectionMode : this.get(&#x27;selectionMode&#x27;)  };

        if(this.get(&#x27;selectionMode&#x27;)===&#x27;cell&#x27;) {
            sobj.cells = this.get(&#x27;selectedCells&#x27;);
        } else if (this.get(&#x27;selectionMode&#x27;)===&#x27;row&#x27;) {
            sobj.rows = this.get(&#x27;selectedRows&#x27;);
        }

        this.fire(&#x27;selection&#x27;,sobj);
    },

    &#x2F;**
     * Event that fires on every &quot;select&quot; action and returns the LAST SELECTED item, either a cell or a row.
     * Please see the event &quot;selection&quot; which provides a cumulative total of all selected items as opposed to
     * just the last item.   (Fired from method [_selectedChange](#method__selectedChange)
     *
     * @event selected
     * @param {Object} obj Return object
     * @param {Object} obj.ochange Change event object passed from attribute &#x27;selected&#x27;
     * @param {Object} obj.record DataTable record (Y.Model) instance for the selection
     *&#x2F;

    &#x2F;**
     * Event that fires on every DataTable &quot;select&quot; event, returns current selections, either cells or rows depending
     * on the current &quot;selectionMode&quot;.  (Fired from method [_selectedChange](#method__selectedChange)
     *
     *
     * @event selection
     * @param {Object} obj Return object
     * @param {Object} obj.selectionMode Current setting of attribute [selectionMode](#attr_selectionMode)
     * @param {Object} obj.cells Returns the current setting of the attribute [selectedCells](#attr_selectedCells)
     * @param {Object} obj.rows Returns the current setting of the attribute [selectedRows](#attr_selectedRows)
     *&#x2F;


    &#x2F;**
     * Called when a &quot;range&quot; selection is detected (i.e. SHIFT key held during click) that selects
     * a range of TD&#x27;s or TR&#x27;s (depending on [selectionMode](#attr_selectionMode) setting.
     *
     * @method _processRange
     * @param {Node} o Last clicked TD of range selection
     * @private
     *&#x2F;
    _processRange: function(o) {
        var tarNew  = o.newVal,
            tarPrev = o.prevVal || null,
            newRec, newRecI, newCol, newColI, prevRec, prevRecI, prevCol, prevColI, delCol, delRow,
            coldir, rowdir, cell, i, j, tr, sel;

        &#x2F;&#x2F;
        &#x2F;&#x2F;  Process through the first and last targets ...
        &#x2F;&#x2F;
        if ( tarNew &amp;&amp; tarPrev ) {
            newRec  = this.getRecord(tarNew);
            newRecI = this.data.indexOf(newRec);
            newCol  = this.getColumnNameByTd(tarNew);
            newColI = Y.Array.indexOf(this.get(&#x27;columns&#x27;),this.getColumn(newCol));
            prevRec  = this.getRecord(tarPrev);
            prevRecI = this.data.indexOf(prevRec);
            prevCol  = this.getColumnNameByTd(tarPrev);
            prevColI = Y.Array.indexOf(this.get(&#x27;columns&#x27;),this.getColumn(prevCol));

            &#x2F;&#x2F; Calculate range offset ... delCol (horiz) and delRow (vertically)
            delCol = newColI - prevColI;
            delRow = newRecI - prevRecI;

            &#x2F;&#x2F; if we have valid deltas, update the range cells.
            if ( delCol !== null &amp;&amp; delRow !== null) {

                if (Y.Lang.isArray(this._selections) ) {
                    this.clearSelections();
                }

                &#x2F;&#x2F; Select a range of CELLS (i.e. TD&#x27;s) ...
                if ( this.get(&#x27;selectionMode&#x27;) === &#x27;cell&#x27; ) {
                    coldir = (delCol&lt;0) ? -1 : 1;
                    rowdir = (delRow&lt;0) ? -1 : 1;
                    cell = tarPrev;

                    for(j=0; j&lt;=Math.abs(delRow); j++) {
                        for(i=0; i&lt;=Math.abs(delCol); i++) {
                            cell = this.getCell(tarPrev,[rowdir*(j),coldir*(i)]);
                            if (cell) {
                                cell.addClass(this._classSelected);
                                sel = this._selectTd(cell);
                                this._selections.push( sel );
                            }
                        }
                    }
                &#x2F;&#x2F; Select a range of ROWS (i.e. TR&#x27;s)
                } else if ( this.get(&#x27;selectionMode&#x27;) === &#x27;row&#x27; ) {

                    rowdir = (delRow&lt;0) ? -1 : 1;
                    tr = this.getRow(prevRecI);

                    for(j=0; j&lt;=Math.abs(delRow); j++) {
                        tr = this.getRow(prevRecI+rowdir*(j));
                        if (tr) {
                            tr.addClass(this._classSelected);
                            sel = this._selectTr(tr);
                            this._selections.push( sel );
                        }
                    }

                }

            }

        }

    },


    &#x2F;**
     * Returns the current settings of row selections, includes multiple selections.  If the
     * current &#x60;selectionMode&#x60; is &quot;cell&quot; mode, this function returns the unique &quot;records&quot; associated with
     * the selected cells.
     *
     * **Returned** &#x60;rows&#x60; {Array} of objects in format;
     * &lt;ul&gt;
     *   &lt;li&gt;&#x60;rows.tr&#x60; {Node} Node instance of the TR that was selected&lt;&#x2F;li&gt;
     *   &lt;li&gt;&#x60;rows.record&#x60; {Model} The Model associated with the data record for the selected TR&lt;&#x2F;li&gt;
     *   &lt;li&gt;&#x60;rows.recordIndex&#x60; {Integer} The record index of the selected TR within the current &quot;data&quot; set&lt;&#x2F;li&gt;
     *   &lt;li&gt;&#x60;rows.recordClientId {String} The record clientId attribute setting&lt;&#x2F;li&gt;
     * &lt;&#x2F;ul&gt;

     * @method _getSelectedRows
     * @return {Array} rows Array of selected &quot;rows&quot; as objects in {tr,record,recordIndex} format
     * @private
     *&#x2F;
    _getSelectedRows: function(){
        var trs  = [],
            rows = [],
            tr, rec;
        
        Y.Array.each(this._selections,function(item){
            if(!item || !item.recClient) {
                return;
            }

            tr  = this.getRow(item.recClient);

            &#x2F;&#x2F; if and only if, it&#x27;s a TR and not in &quot;trs&quot; array ... then add it
            if ( Y.Array.indexOf(trs,tr) === -1 ) {
                rec = this.data.getByClientId( item.recClient );
                trs.push( tr );
                rows.push({
                    tr:             tr,    &#x2F;&#x2F; this is an OLD, stale TR from pre-sort
                    record:         rec,
                    recordIndex:    this.data.indexOf(rec),
                    recordClientId: item.recClient
                });
            }
        },this);
        return rows;
    },



    &#x2F;**
     * Getter method that returns an Array of the selected cells in record&#x2F;column coordinate format.
     * If rows or TR elements were selected, it adds all of the row&#x27;s child TD&#x27;s.
     *
     * **Returned** &#x60;cells&#x60; {Array} of objects in format;
     * &lt;ul&gt;
     *   &lt;li&gt;&#x60;cells.td&#x60; {Node} TD Node for this cell.&lt;&#x2F;li&gt;
     *   &lt;li&gt;&#x60;cells.record&#x60; {Model} Record for this cell as a Y.Model&lt;&#x2F;li&gt;
     *   &lt;li&gt;&#x60;cells.recordIndex&#x60; {Integer} Record index for this cell in the current &quot;data&quot; set&lt;&#x2F;li&gt;
     *   &lt;li&gt;&#x60;cells.column&#x60; {Object} Column for this cell defined in original &quot;columns&quot; DataTable attribute&lt;&#x2F;li&gt;
     *   &lt;li&gt;&#x60;cells.columnName&#x60; {String} Column name or key associated with this cell&lt;&#x2F;li&gt;
     *   &lt;li&gt;&#x60;cells.columnIndex&#x60; {Integer} Column index of the column, within the &quot;columns&quot; data&lt;&#x2F;li&gt;
     * &lt;&#x2F;ul&gt;
     *
     * @method _getSelectedCells
     * @return {Array} cells The selected cells in {record,recordIndex,column,columnName,columnIndex} format
     * @private
     *&#x2F;
    _getSelectedCells: function(){
        var cells = [],
            cols  = this.get(&#x27;columns&#x27;),
            col, tr, rec;

        Y.Array.each(this._selections,function(item){
            if (!item) {
                return;
            }

            if ( item.td ) {
                col = this.getColumn(item.colName);
                tr  = item.tr;
                rec = this.data.getByClientId(item.recClient);

                cells.push({
                    td:          item.td,
                    record:      rec,
                    recordIndex: this.data.indexOf(rec),
                    recordClientId:  item.recClient,
                    column:      col,
                    columnName:  item.colName,
                    columnIndex: Y.Array.indexOf(cols,col)
                });
            } else if ( item.tr ) {
                tr = item.tr;
                rec = this.data.getByClientId(item.recClient);
                var tdNodes = tr.all(&quot;td&quot;);
                if ( tdNodes ) {
                    tdNodes.each(function(td){
                        col = this.getColumnByTd(td);
                        cells.push({
                            td:          td,
                            record:      rec,
                            recordIndex: this.data.indexOf(rec),
                            recordClientId:  item.recClient,
                            column:      col,
                            columnName:  col.key || col.name,
                            columnIndex: Y.Array.indexOf(cols,col)
                        });
                    },this);
                }
            }
        },this);
        return cells;
    },

    &#x2F;**
     * Setter method for attribute &#x60;selectedCells&#x60; that takes an array of cells as input and sets them
     * as the current selected set with appropriate visual class.
     *
     * @method _setSelectedCells
     * @param {Array} val The desired cells to set as selected, in {record:,column:} format
     * @param {String|Number} val.record Record for this cell as either record index or record clientId
     * @param {String|Number} val.column Column for this cell as either the column index or &quot;key&quot; or &quot;name&quot;
     * @return {Array}
     * @private
     *&#x2F;
    _setSelectedCells: function(val){
        this._selections = [];
        if ( Y.Lang.isArray(val) &amp;&amp; this.data.size() &gt; val.length ) {
            Y.Array.each(val,function(item) {
                var row, col, td, ckey,sel;
                row = ( Y.Lang.isNumber(item.record) ||
                    typeof item.record ===&#x27;string&#x27;) ? this.getRow( item.record ) : row;
                col = ( Y.Lang.isNumber(item.column) ||
                    typeof item.column ===&#x27;string&#x27; ) ? this.getColumn(item.column) : col;

                if ( row &amp;&amp; col ) {
                    ckey = col.key || col.name;
                    if ( ckey ) {
                        td  = row.one(&#x27;.&#x27;+this.getClassName(&#x27;col&#x27;)+&#x27;-&#x27;+ckey);
                        sel = this._selectTd(td);
                        if(sel) {
                            this._selections.push(sel);
                        }
                        td.addClass(this._classSelected);
                    }
                }

            },this);
        }
        return val;
    },


    &#x2F;**
     * A setter method for attribute &#x60;selectedRows&#x60; that takes as input an array of desired DataTable
     * record indices to be &quot;selected&quot;, clears existing selections and sets the &quot;selected&quot; records and
     * highlights the TR&#x27;s
     *
     * @method _setSelectedRows
     * @param  {Array} val Array of record indices (or record &quot;clientId&quot;) desired to be set as selected.
     * @return {Array} records Array of DataTable records (Y.Model) for each selection chosen
     * @private
     *&#x2F;
    _setSelectedRows: function(val){
        this._selections = [];
        if ( Y.Lang.isArray(val) &amp;&amp; this.data.size() &gt; val.length ) {
            Y.Array.each(val,function(item){
                var tr = this.getRow(item),
                    sel;
                if ( tr ) {
                    sel = this._selectTr(tr);
                    if(sel) {
                        this._selections.push( sel );
                    }
                    tr.addClass(this._classSelected);
                }
            },this);
        }
        return val;
    },


    &#x2F;**
     * Method that returns a TD&#x27;s &quot;selection obj&quot; expected for the _selections buffer
     * @method _selectTd
     * @param tar {Node}  A Node instance of TD to be prepared for selection
     * @return {Object} obj Returned object includes properties (td,tr,recClient,colName)
     * @private
     *&#x2F;
    _selectTd : function(tar){
        var rec,col,rtn=false;
        if(tar &amp;&amp; tar.get(&#x27;tagName&#x27;).toLowerCase() === &#x27;td&#x27;) {
            rec = this.getRecord(tar.ancestor());
            col = this.getColumnByTd(tar);
            rtn = {
                td:        tar,
                tr:        tar.ancestor(),
                recClient: (rec) ? rec.get(&#x27;clientId&#x27;) : null,
                colName:   col.key || col.name || null
            };
        }
        return rtn;
    },

    &#x2F;**
     * Method that returns a TR&#x27;s &quot;selection obj&quot; expected for the _selections buffer
     * @method _selectTr
     * @param tar {Node}  A Node instance of TR to be prepared for selection
     * @return {Object} obj Returned object includes properties (tr,recClient)
     * @private
     *&#x2F;
    _selectTr : function(tar){
        var rec, rtn = false;
        if(tar &amp;&amp; tar.get(&#x27;tagName&#x27;).toLowerCase() === &#x27;tr&#x27;) {
            rec = this.getRecord(tar);
            rtn = {
                tr:        tar,
                recClient: (rec) ? rec.get(&#x27;clientId&#x27;) : null
            };
        }
        return rtn;
    },


    &#x2F;**
     * Method is fired AFTER a &quot;reset&quot; action takes place on the &quot;data&quot;, usually related to a column sort.
     * This function reads the pre-sorted selections that were stored by  [_beforeResetDataSelect](#method__beforeResetDataSelect)
     * temporarily in this._selections.
     *
     * Depending upon the current &quot;selectionMode&quot;, either post-sorted TBODY selections are re-applied, by determining either
     * the TR&#x27;s (from the Model data) or the TD&#x27;s (from the Model and Column Index data).
     *
     * @method _afterResetDataSelect
     * @private
     *&#x2F;
    _afterResetDataSelect: function() {
        if( !this._selections || this._selections.length === 0 ) {
            return;
        }
        var tr, td, buffer = [], colIndex, col,
            cols = this.get(&#x27;columns&#x27;);

        this._clearAll(this._classSelected);


        Y.Array.each(this._selections,function(item){
            if( this.get(&#x27;selectionMode&#x27;) === &#x27;row&#x27; &amp;&amp; item.recClient ) {
                &#x2F;&#x2F; the &quot;item&quot; is a Model pushed prior to the &quot;sort&quot; action ...
                tr = this.getRow(item.recClient);
                if( tr ) {
                    buffer.push( this._selectTr(tr) );
                    tr.addClass(this._classSelected);
                }
            } else if (this.get(&#x27;selectionMode&#x27;) === &#x27;cell&#x27; &amp;&amp; item.recClient &amp;&amp; item.colName ) {
                tr = this.getRow(item.recClient);
                col = this.getColumn(item.colName);
                colIndex = Y.Array.indexOf(cols,col);
                td = (tr &amp;&amp; colIndex &gt;= 0) ? tr.all(&quot;td&quot;).item(colIndex) : null;
                if(tr &amp;&amp; td) {
                    buffer.push( this._selectTd(td) );
                    td.addClass(this._classSelected);
                }
            }
        },this);

        &#x2F;&#x2F; swap out the temporary buffer, for the current selections ...
        this._selections = buffer;

    },

    &#x2F;**
     * Method used to derive from the clicked selection, either the TR or TD of the selection, and
     * returns the current &#x60;selectionMode&#x60; or &#x60;highlightMode&#x60; Node (based on the setting of prefix).
     *
     * This method adds the required class, and if erasePrev is true, removes the class from the prior setting.
     *
     * @method _processNodeAction
     * @param {Object} o Attribute change event object
     * @param {String} prefix
     * @param {Boolean} erasePrev
     * @return {Node} node Returned target Y.Node, either TR or TD based upon current &#x60;selectionMode&#x60; or &#x60;highlightMode&#x60;
     * @private
     *&#x2F;
    _processNodeAction: function(o, prefix, erasePrev ){
        var tar = o.newVal,
            tarNew, tarPrev, modeName, className;

        if ( prefix === &#x27;highlight&#x27;) {
            modeName  = prefix + &#x27;Mode&#x27;;
            className = this._classHighlight;
        } else if ( prefix === &#x27;select&#x27; ) {
            modeName  = &#x27;selectionMode&#x27;;
            className = this._classSelected;
        }

        if ( this.get(modeName) === &quot;cell&quot; ) {
            tarNew  = tar || null;
            tarPrev = o.prevVal || null;
        } else if ( this.get(modeName) === &quot;row&quot; ) {
            if ( tar ) {
                tarNew = (tar.get(&#x27;tagName&#x27;).search(&#x2F;td&#x2F;i) === 0 ) ? tar.ancestor(&#x27;tr&#x27;)
                    : ( tar.get(&#x27;tagName&#x27;).search(&#x2F;tr&#x2F;i) === 0 ) ? tar : null ;
            }
            tarPrev = o.prevVal;
            if (tarPrev) {
                tarPrev = (tarPrev.get(&#x27;tagName&#x27;).search(&#x2F;td&#x2F;i) === 0 ) ? tarPrev.ancestor(&#x27;tr&#x27;)
                    : ( tarPrev.get(&#x27;tagName&#x27;).search(&#x2F;tr&#x2F;i) === 0 ) ? tarPrev : null ;
            }
        }

        if ( tarPrev &amp;&amp; erasePrev ) {
            tarPrev.removeClass(className);
        }

        if ( tarNew ) {
            tarNew.addClass(className);
        }

        return tarNew;
    },


    &#x2F;**
     * Method removes the specified &#x60;type&#x60; CSS class from all nodes within the TBODY data node.
     * @method _clearAll
     * @param {String} type Class name to remove from all nodes attached to TBODY DATA
     * @private
     *&#x2F;
    _clearAll: function(type){
        var nodes = this.get(&#x27;boundingBox&#x27;).one(&quot;.&quot;+this.getClassName(&#x27;data&#x27;));
        if ( nodes ) {
            nodes.all(&#x27;.&#x27;+type).removeClass(type);
        }
    },

    &#x2F;**
     * Setter for &#x60;highlightMode&#x60; attribute, removes prior event handle (if exists) and defines
     * a new delegated &quot;mouseover&quot; handler that updates the &#x60;highlighted&#x60; attribute.
     *
     * A change to this setting clears all prior highlighting.
     *
     * @method _setHighlightMode
     * @param val
     * @return {*}
     * @private
     *&#x2F;
    _setHighlightMode: function(val){
        if ( this._subscrHighlight ) {
            this._subscrHighlight.detach();
        }

        if(val===&#x27;none&#x27;) {
            return;
        } else if (val.toLowerCase) {
            val = val.toLowerCase();
        }

        this._subscrHighlight = this.delegate(&quot;mouseover&quot;,function(e){
                var tar = e.currentTarget;
                this.set(&#x27;highlighted&#x27;,tar);
            },&quot;tr td&quot;,this);

        &#x2F;&#x2F;this._clearAll(this._classHighlight);
        this.clearHighlighted();
        return val;
    },

    &#x2F;**
     * Setter for &#x60;selectionMode&#x60; attribute, removes prior event handle (if exists) and defines
     * a new delegated &quot;click&quot; handler that updates the &#x60;selected&#x60; attribute.
     *
     * A change to this setting clears all prior selections.
     *
     * @method _setSelectionMode
     * @param val
     * @return {*}
     * @private
     *&#x2F;
    _setSelectionMode: function(val){
        var oSelf = this;
        if ( this._subscrSelect ) {
            this._subscrSelect.detach();
        }

        if(val===&#x27;none&#x27;) {
            return;
        } else if (val.toLowerCase) {
            val = val.toLowerCase();
        }

        this._subscrSelect = this.delegate(&quot;click&quot;,function(e){
                var tar = e.currentTarget;

               &#x2F;&#x2F; Disabled 11&#x2F;16&#x2F;12: was preventing checkbox listeners to fire
               &#x2F;&#x2F; e.halt(true);

                oSelf._clickModifiers = {
                    ctrlKey:  e.ctrlKey,
                    altKey:   e.altKey,
                    metaKey:  e.metaKey,
                    shiftKey: e.shiftKey,
                    which:    e.which,
                    button:   e.button
                };

                oSelf.set(&#x27;selected&#x27;,tar);

            },&quot;tr td&quot;,oSelf);
        &#x2F;&#x2F;this._clearAll(this._classSelected);
        this.clearSelections();
        return val;
    },

    &#x2F;**
     * Helper method to clear DOM &quot;selected&quot; text or ranges
     * @method _clearDOMSelection
     * @private
     *&#x2F;
    _clearDOMSelection: function(){
        var sel = (Y.config.win.getSelection) ? Y.config.win.getSelection()
            : (Y.config.doc.selection) ? Y.config.doc.selection : null;

        if ( sel &amp;&amp; sel.empty ) {
            sel.empty();   &#x2F;&#x2F; works on chrome
        }
        if ( sel &amp;&amp; sel.removeAllRanges ) {
            sel.removeAllRanges();  &#x2F;&#x2F; works on FireFox
        }
    }

});

Y.DataTable.Selection = DtSelection;
Y.Base.mix(Y.DataTable, [Y.DataTable.Selection]);


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
