<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>gallery-js&#x2F;datatable-editable.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/PickList.html">PickList</a></li>
            
                <li><a href="..&#x2F;classes/Y.Calendar.JumpNavView.html">Y.Calendar.JumpNavView</a></li>
            
                <li><a href="..&#x2F;classes/Y.ContextMenuView.html">Y.ContextMenuView</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.BaseCellInlineEditor.html">Y.DataTable.BaseCellInlineEditor</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.BaseCellPopupEditor.html">Y.DataTable.BaseCellPopupEditor</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.CheckboxSelect.html">Y.DataTable.CheckboxSelect</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.Editable.html">Y.DataTable.Editable</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.html">Y.DataTable.EditorOptions</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.autocomplete.html">Y.DataTable.EditorOptions.autocomplete</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.calendar.html">Y.DataTable.EditorOptions.calendar</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.checkbox.html">Y.DataTable.EditorOptions.checkbox</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.date.html">Y.DataTable.EditorOptions.date</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.dropdown.html">Y.DataTable.EditorOptions.dropdown</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.inline.html">Y.DataTable.EditorOptions.inline</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.inlineAC.html">Y.DataTable.EditorOptions.inlineAC</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.inlineDate.html">Y.DataTable.EditorOptions.inlineDate</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.inlineNumber.html">Y.DataTable.EditorOptions.inlineNumber</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.number.html">Y.DataTable.EditorOptions.number</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.radio.html">Y.DataTable.EditorOptions.radio</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.text.html">Y.DataTable.EditorOptions.text</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.EditorOptions.textarea.html">Y.DataTable.EditorOptions.textarea</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.Formatters.html">Y.DataTable.Formatters</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.Paginator.html">Y.DataTable.Paginator</a></li>
            
                <li><a href="..&#x2F;classes/Y.DataTable.Selection.html">Y.DataTable.Selection</a></li>
            
                <li><a href="..&#x2F;classes/Y.FooterView.html">Y.FooterView</a></li>
            
                <li><a href="..&#x2F;classes/Y.PaginatorModel.html">Y.PaginatorModel</a></li>
            
                <li><a href="..&#x2F;classes/Y.PaginatorView.html">Y.PaginatorView</a></li>
            
                <li><a href="..&#x2F;classes/Y.Plugin.Calendar.JumpNav.html">Y.Plugin.Calendar.JumpNav</a></li>
            
                <li><a href="..&#x2F;classes/Y.Plugin.DataTableContextMenu.html">Y.Plugin.DataTableContextMenu</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/DataTable.html">DataTable</a></li>
            
                <li><a href="..&#x2F;modules/FooterView.html">FooterView</a></li>
            
                <li><a href="..&#x2F;modules/gallery-contextmenu-view.html">gallery-contextmenu-view</a></li>
            
                <li><a href="..&#x2F;modules/gallery-datatable-celleditor-inline.html">gallery-datatable-celleditor-inline</a></li>
            
                <li><a href="..&#x2F;modules/gallery-datatable-celleditor-popup.html">gallery-datatable-celleditor-popup</a></li>
            
                <li><a href="..&#x2F;modules/gallery-datatable-contextmenu.html">gallery-datatable-contextmenu</a></li>
            
                <li><a href="..&#x2F;modules/gallery-datatable-editable.html">gallery-datatable-editable</a></li>
            
                <li><a href="..&#x2F;modules/gallery-datatable-formatters.html">gallery-datatable-formatters</a></li>
            
                <li><a href="..&#x2F;modules/gallery-datatable-paginator.html">gallery-datatable-paginator</a></li>
            
                <li><a href="..&#x2F;modules/gallery-datatable-selection.html">gallery-datatable-selection</a></li>
            
                <li><a href="..&#x2F;modules/gallery-paginator-view.html">gallery-paginator-view</a></li>
            
                <li><a href="..&#x2F;modules/gallery-picklist.html">gallery-picklist</a></li>
            
                <li><a href="..&#x2F;modules/Selection.html">Selection</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: gallery-js&#x2F;datatable-editable.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 A DataTable class extension that configures a DT for &quot;editing&quot;, current deployment supports cell editing
 (and planned near-term support for row editing).

 This module is essentially a base wrapper-class to setup DT for editing with the appropriate attributes and
 listener creation &#x2F; detachment.  The real guts of &quot;datatable-editing&quot; is in the View class definitions, within
 the gallery-datatable-celleditor-inline and gallery-datatable-celleditor-inline modules (and possibly future
 editor View class modules).

 #### Functionality

 The module is basically intended to keep track of the editing state (via [editable](#attr_editable) attribute) and
 housekeeping functions with regard to managing editor View instance creation, rendering and destruction.

 By design this module attempts to group common editor View instances wherever possible.  So for a DT with 14 columns
 all set with &quot;inline&quot; View classes only 1 View instance is created.
 &lt;br&#x2F;&gt;Likewise if a DT uses 4 different &quot;calendar&quot; editor View types but each one as slightly different &quot;editorConfig&quot;,
 then this module creates 4 different calendar View instances to handle the different configurations.

 Listeners are set for the &quot;cellEditorSave&quot; event and saved to the active &quot;data&quot; setting within this module.

 Additional capability is provided for cell editing situations to add CSS classes to TD&#x27;s which are added to &quot;editable&quot;
 columns (e.g. cursor) to indicate they are &quot;clickable&quot;.

 This module works sortable, scrollable (y-scrolling currently) to make changes to the client-side of the DT model
 (remote updates should be provided via ModelList sync or user-defined listeners.)


 #### Attributes

 Presently three attributes are provided;
 [editable](#attr_editable), [editOpenType](#attr_editOpenType) and [defaultEditor](#attr_defaultEditor).

 The primary ATTR is the [editable](#attr_editable), which is used to toggle on&#x2F;off the editing state of the DT
 instance.

 The [defaultEditor](#attr_defaultEditor) attribute is used to setup a cell editor View instance to be used on all editable columns
 that don&#x27;t already have an editor assigned.

 ##### Column Properties

 In addition to a few new attributes the module also recognizes some new column properties in order to support
 cell-editing in particular;
 &lt;table&gt;
 &lt;tr&gt;&lt;th&gt;editable&lt;&#x2F;th&gt;&lt;td&gt;{Boolean}&lt;&#x2F;td&gt;&lt;td&gt;Flag to indicate if column is editable (set &#x60;editable:false&#x60; to exclude an
 individual column)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
 &lt;tr&gt;&lt;th&gt;editor&lt;&#x2F;th&gt;&lt;td&gt;{String}&lt;&#x2F;td&gt;&lt;td&gt;Name of the defined Y.DataTable.EditorOptions View configuration for this column.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
 &lt;tr&gt;&lt;th&gt;editorConfig&lt;&#x2F;th&gt;&lt;td&gt;{Object}&lt;&#x2F;td&gt;&lt;td&gt;Passed to the View editor class when instantiated, and Y.merge&#x27;ed in to become View class
 attributes.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
 &lt;&#x2F;table&gt;

 When this module is loaded and the &quot;editable:true&quot; attribute is set, it attempts to economize on the &quot;instantiation cost&quot;
 of creating View instances by identifying only editor Views that are required based upon column definitions and&#x2F;or the
 defaultEditor attribute. (e.g. if all columns are &quot;text&quot; editors, only one &quot;text&quot; editor View is instantiated)

 ##### ... More Info

 The module fires the event [cellEditorSave](#event_cellEditorSave), which can be listened for to provide updating
 of remote data back to a server (assuming a ModelList &quot;sync&quot; layer is NOT used).  Haven&#x27;t provided the equivalent to
 YUI 2.x&#x27;s &quot;asyncSubmitter&quot; because I think this event could easily be listened to in order to provide follow-on
 updating to remote data stores.

 A new class Object (Y.DataTable.EditorOptions) is added to the DataTable namespace that serves as the
 datastore of the editor View configuration properties.  Each &quot;key&quot; (object property) within this object
 is an entrypoint to a specific editor configuration, which are defined in the separate View class extensions (presently
 gallery-datatable-celleditor-inline and gallery-datatable-celleditor-popup. Please see those for specifics.)

 ###### KNOWN ISSUES:
   &lt;ul&gt;
   &lt;li&gt;Works minimally with &quot;y&quot; scrolling, &quot;x&quot; scrolling still needs work.&lt;&#x2F;li&gt;
   &lt;li&gt;Initial editor invocation is limited to &quot;mouse&quot; actions on TD only (although keyboard navigation cell-to-cell is available).&lt;&#x2F;li&gt;
   &lt;li&gt;An issue arises on &quot;datatable.destroy()&quot; in Chrome from time to time when using inline editors, still investigating why.&lt;&#x2F;li&gt;
   &lt;&#x2F;ul&gt;

 ###### FUTURE:
 This module will be amended to add support for &quot;row&quot; editing, if required.

 @module gallery-datatable-editable
 @class Y.DataTable.Editable
 @extends Y.DataTable
 @author Todd Smith
 @since 3.8.0
 **&#x2F;
DtEditable = function(){};

&#x2F;&#x2F; Define new attributes to support editing
DtEditable.ATTRS = {

    &#x2F;**
     * A boolean flag that sets the DataTable state to allow editing (either inline or popup cell editing).
     * (Future may support row editing also)
     *
     * @attribute editable
     * @type boolean
     * @default false
     *&#x2F;
    editable: {
        valueFn:    function(){ return false;},
        setter:     &#x27;_setEditable&#x27;,
        validator:  Y.Lang.isBoolean
    },

    &#x2F;**
     * Defines the cell editing event type on the TD that initiates the editor, used to
     * specify the listener that invokes an editor.
     *
     * Note: IMHO The only sensible options are &#x27;click&#x27; or &#x27;dblclick&#x27;
     *
     * @attribute editOpenType
     * @type string
     * @default &#x27;dblclick&#x27;
     *&#x2F;
    editOpenType: {
        value:      &#x27;dblclick&#x27;,
        setter:     &#x27;_setEditOpenType&#x27;,
        validator:  Y.Lang.isString
    },

    &#x2F;**
     * Specifies a default editor name to respond to an editing event defined in [_editOpenType](#attr_editOpenType)
     * attribute.  The default editor is used if the DataTable is in editing mode (i.e. &quot;editable:true&quot;) and if
     * the column DOES NOT include a property editable:false in its definitions.
     *
     * Cell editors are typically assigned by setting a column property (i.e. editor:&#x27;text&#x27; or &#x27;date&#x27;) on each
     * individual column.
     *
     * This attribute can be used to set a single editor to work on every column without having to define it on each
     * column.
     *
     * @attribute defaultEditor
     * @type string
     * @default &#x27;none&#x27;
     *&#x2F;
    defaultEditor : {
        value:      &#x27;none&#x27;,
        setter:     &#x27;_setDefaultEditor&#x27;,
        validator:  function(v){ return Y.Lang.isString(v) || v === null; }
    }
};

&#x2F;&#x2F; Add static props and public&#x2F;private methods to be added to DataTable
Y.mix( DtEditable.prototype, {

&#x2F;&#x2F; -------------------------- Placeholder Private Properties  -----------------------------

    &#x2F;**
     Holds the View instance of the active cell editor currently displayed
     @property _openEditor
     @type Y.View
     @default null
     @private
     @static
     **&#x2F;
    _openEditor:        null,

    &#x2F;**
     Holds the current record (i.e. a Model class) of the TD being edited
     (Note: this may not always work, better to use &quot;clientId&quot; of the record, i.e. sorting, etc..)
     @property _openRecord
     @type Model
     @default null
     @private
     @static
     **&#x2F;
    _openRecord:        null,

    &#x2F;**
     Holds the column key (or name) of the TD cell being edited
     @property _openColKey
     @type String
     @default null
     @private
     @static
     **&#x2F;
    _openColKey:        null,

    &#x2F;**
     Holds the TD Node currently being edited
     @property _openTd
     @type Node
     @default null
     @private
     @static
     **&#x2F;
    _openTd:            null,

    &#x2F;**
     Holds the cell data for the actively edited TD, a complex object including the
     following;  {td, value, recClientId, colKey}
     @property _openCell
     @type Object
     @default null
     @private
     @static
     **&#x2F;
    _openCell:          null,

&#x2F;&#x2F; -------------------------- Subscriber handles  -----------------------------

    &#x2F;**
     Placeholder for the DT level event listener for &quot;editableChange&quot; attribute.
     @property _subscrEditable
     @type EventHandle
     @default null
     @private
     @static
     **&#x2F;
    _subscrEditable:     null,

    &#x2F;**
     Placeholder Array for TD editor invocation event handles (i.e. click or dblclick) that
     are set on the TBODY to initiate cellEditing.
     @property _subscrCellEditors
     @type Array of EventHandles
     @default null
     @private
     @static
     **&#x2F;
    _subscrCellEditors:    null,

    &#x2F;**
     Placeholder for event handles for scrollable DT that listens to &quot;scroll&quot; events and repositions editor
     (we need two listeners, one for each of X or Y scroller)
     @property _subscrCellEditorScrolls
     @type Array of EventHandles
     @default null
     @private
     @static
     **&#x2F;
    _subscrCellEditorScrolls: null,

    &#x2F;**
     Shortcut to the CSS class that is added to indicate a column is editable
     @property _classColEditable
     @type String
     @default &#x27;yui3-datatable-col-editable&#x27;
     @private
     @static
     **&#x2F;
    _classColEditable:  null,

    &#x2F;**
     Placeholder hash that stores the &quot;common&quot; editors, i.e. standard editor names that occur
     within Y.DataTable.EditorOptions and are used in this DT.

     This object holds the View instances, keyed by the editor &quot;name&quot; for quick hash reference.
     The object is populated in method [_buildColumnEditors](#method__buildColumnEditors).

     @property _commonEditors
     @type Object
     @default null
     @private
     @static
     **&#x2F;
    _commonEditors:  null,

    &#x2F;**
     Placeholder hash that stores cell editors keyed by column key (or column name) where the value
     for the associated key is either a (a) {String} which references an editor name in the [_commonEditors](#property__commonEditors)
     hash or (b) {View} instance for a customized editor View instance (typically one with specified &quot;editorConfig&quot; in the
     column definition).

     The object is populated in method [_buildColumnEditors](#method__buildColumnEditors).

     @property _columnEditors
     @type Object
     @default null
     @private
     @static
     **&#x2F;
    _columnEditors: null,

    &#x2F;&#x2F; future
    &#x2F;&#x2F;_editableType:      null,   &#x2F;&#x2F;  &#x27;cell&#x27;, &#x27;row&#x27;, &#x27;inline?&#x27;

&#x2F;&#x2F;==========================  LIFECYCLE METHODS  =============================

    &#x2F;**
     * Initializer that sets up listeners for &quot;editable&quot; state and sets some CSS names
     * @method initializer
     * @protected
     *&#x2F;
    initializer: function(){

     &#x2F;&#x2F;   if(this.get(&#x27;editable&#x27;)===true) {
     &#x2F;&#x2F;       this._setEditableMode(true);
     &#x2F;&#x2F;   }

        this._classColEditable = this.getClassName(&#x27;col&#x27;,&#x27;editable&#x27;);

        this._bindEditable();

        return this;
    },

    &#x2F;**
     * Cleans up ALL of the DT listeners and the editor View instances and generated private props
     * @method destructor
     * @protected
     *&#x2F;
    destructor:function() {
        &#x2F;&#x2F; detach the &quot;editableChange&quot; listener on the DT
        this.set(&#x27;editable&#x27;,false);
        this._unbindEditable();
    },


    &#x2F;**
     * Sets up listeners for the DT editable module,
     * @method _bindEditable
     * @private
     *&#x2F;
    _bindEditable: function(){

        Y.Do.after(this._updateAllEditableColumnsCSS,this,&#x27;syncUI&#x27;);

        this.after(&#x27;sort&#x27;, this._afterEditableSort);
    },

    &#x2F;**
     * Unbinds ALL of the popup editor listeners and removes column editors.
     * This should only be used when the DT is destroyed
     * @method _unbindEditable
     * @private
     *&#x2F;
    _unbindEditable: function() {

        &#x2F;&#x2F; destroy any currently open editor
        if(this._openEditor &amp;&amp; this._openEditor.destroy) {
            this._openEditor.destroy();
            &#x2F;&#x2F;this._openEditor.destroy({remove:true});
        }

        if(this._subscrCellEditorScrolls &amp;&amp; Y.Lang.isArray(this._subscrCellEditorScrolls) ) {
            Y.Array.each(this._subscrCellEditorScroll, function(dh){
                if(dh &amp;&amp; dh.detach) {
                    dh.detach();
                }
            });
            this._subscrCellEditorScrolls = [];
        }

        this._unsetEditor();

        &#x2F;&#x2F; run through all instantiated editors and destroy them
        this._destroyColumnEditors();

    },

    &#x2F;**
     * Binds listeners to cell TD &quot;open editing&quot; events (i.e. either click or dblclick)
     * as a result of DataTable setting &quot;editable:true&quot;.
     *
     * Also sets a body listener for ESC key, to close the current open editor.
     *
     * @method _bindCellEditingListeners
     * @private
     *&#x2F;
    _bindCellEditingListeners: function(){

        &#x2F;&#x2F; clear up previous listeners, if any ...
        if(this._subscrCellEditors) {
            this._unbindCellEditingListeners();
        }

        &#x2F;&#x2F; create listeners
        this._subscrCellEditors = [];
        this._subscrCellEditors.push(
            this.delegate( this.get(&#x27;editOpenType&#x27;), this.openCellEditor,&quot;tbody.&quot; + this.getClassName(&#x27;data&#x27;) + &quot; td&quot;,this)
        );

        &#x2F;&#x2F; Add a ESC key listener on the body (hate doing this!) to close editor if open ...
        this._subscrCellEditors.push( Y.one(&#x27;body&#x27;).after(&#x27;keydown&#x27;, Y.bind(this._onKeyEsc,this) ) );

        &#x2F;&#x2F; Add listeners to all &#x27;celleditors&#x27;
        this.on(&#x27;celleditor:editorSave&#x27;,this._onCellEditorSave);
        this.on(&#x27;celleditor:editorCancel&#x27;,this._onCellEditorCancel);
        this.on(&#x27;celleditor:keyDirChange&#x27;,this._onKeyDirChange);

    },

    &#x2F;**
     * Unbinds the TD click delegated click listeners for initiating editing in TDs
     * @method _unbindCellEditingListeners
     * @private
     *&#x2F;
    _unbindCellEditingListeners: function(){

        if(!this._subscrCellEditors) {
            return;
        }

        &#x2F;&#x2F; this._subscrCellEditors
        if (this._subscrCellEditors) {
            Y.Array.each(this._subscrCellEditors,function(e){
                if(e &amp;&amp; e.detach) {
                    e.detach();
                }
            });
        }

        this._subscrCellEditors = null;

        this.detach(&#x27;celleditor:*&#x27;);

    },

    &#x2F;**
     * Sets up listeners for DT scrollable &quot;scroll&quot; events
     * @method _bindEditorScroll
     * @private
     *&#x2F;
    _bindEditorScroll: function() {
        this._subscrCellEditorScrolls = [];
        if(this._xScroll &amp;&amp; this._xScrollNode) {
            this._subscrCellEditorScrolls.push( this._xScrollNode.on(&#x27;scroll&#x27;, this._onScrollUpdateCellEditor, this ) );
        }
        if(this._yScroll &amp;&amp; this._yScrollNode) {
            this._subscrCellEditorScrolls.push( this._yScrollNode.on(&#x27;scroll&#x27;, this._onScrollUpdateCellEditor, this ) );
        }

    },


&#x2F;&#x2F;==========================  PUBLIC METHODS  =============================

    &#x2F;**
     * Opens the given TD eventfacade or Node with it&#x27;s assigned cell editor.
     *
     * @method openCellEditor
     * @param e {EventFacade|Node} Passed in object from an event OR a TD Node istance
     * @public
     *&#x2F;
    openCellEditor: function(e) {
        var td       = e.currentTarget || e,
            col      = this.getColumnByTd(td),
            colKey   = col.key || col.name,
            editorRef = (colKey) ? this._columnEditors[colKey] : null,
            editorInstance = (editorRef &amp;&amp; Y.Lang.isString(editorRef) ) ? this._commonEditors[editorRef] : editorRef;

        if(!td) {
            return;
        }

        &#x2F;&#x2F; First time in,
        if( (this._yScroll || this._xScroll) &amp;&amp; !this._subscrCellEditorScroll) {
            this._bindEditorScroll();
        }

        &#x2F;&#x2F;
        &#x2F;&#x2F; Bailout if column is null, has editable:false or no editor assigned ...
        &#x2F;&#x2F;
        if(col &amp;&amp; col.editable === false &amp;&amp; !editorInstance) {
            return;
        }

        &#x2F;&#x2F; Hide any editor that may currently be open ... unless it is the currently visible one
        if(this._openEditor) {
            if ( this._openEditor === editorInstance ) {
                this._openEditor.hideEditor();
            } else {
                this.hideCellEditor();
            }
        }

        &#x2F;&#x2F;
        &#x2F;&#x2F;  If the editorInstance exists, populate it and show it
        &#x2F;&#x2F;
        &#x2F;&#x2F;TODO:  fix this to rebuild new editors if user changes a column definition on the fly
        &#x2F;&#x2F;
        if(editorInstance) {

            &#x2F;&#x2F;
            &#x2F;&#x2F;  Set private props to the open TD we are editing, the editor instance, record and column name
            &#x2F;&#x2F;
            this._openTd     = td;                      &#x2F;&#x2F; store the TD
            this._openEditor = editorInstance;          &#x2F;&#x2F; placeholder to the open Editor View instance
            this._openRecord = this.getRecord(td);      &#x2F;&#x2F; placeholder to the editing Record
            this._openColKey = colKey;                  &#x2F;&#x2F; the column key (or name)

            this._openCell   = {
                td:             td,
                value:          this._openRecord.get(colKey),
                recClientId:    this._openRecord.get(&#x27;clientId&#x27;),
                colKey:         colKey
            };

            &#x2F;&#x2F; Define listeners onto this open editor ...
            &#x2F;&#x2F;this._bindOpenEditor( this._openEditor );

            &#x2F;&#x2F;
            &#x2F;&#x2F;  Set the editor Attributes and render it ... (display it!)
            &#x2F;&#x2F;
            this._openEditor.setAttrs({
       &#x2F;&#x2F;         hostDT: this,
                cell:   this._openCell,
                value:  this._openRecord.get(colKey)
            });

            this._openEditor.showEditor(td);

        }

    },


    &#x2F;**
     * Cleans up a currently open cell editor View and unbinds any listeners that this DT had
     * set on the View.
     * @method hideCellEditor
     * @public
     *&#x2F;
    hideCellEditor: function(){
        if(this._openEditor) {
            this._openEditor.hideEditor();
            this._unsetEditor();
        }
    },

    &#x2F;**
     * Utility method that scans through all editor instances and hides them
     * @method hideAllCellEditors
     * @private
     *&#x2F;
    hideAllCellEditors: function(){
        this.hideCellEditor();
        var ces = this._getAllCellEditors();
        Y.Array.each( ces, function(editor){
            if(editor &amp;&amp; editor.hideEditor) {
                editor.hideEditor();
            }
        });
    },

    &#x2F;**
     * Over-rideable method that can be used to do other user bindings ?
     *   (like hideEditor on mouseout, etc...)
     * @method bindEditorListeners
     * @public
     *&#x2F;
    bindEditorListeners: function(){
        return;
    },

    &#x2F;**
     * Returns all cell editor View instances for the editable columns of the current DT instance
     * @method getCellEditors
     * @return editors {Array} Array containing an Object as {columnKey, cellEditor, cellEditorName}
     *&#x2F;
    getCellEditors: function(){
        var rtn = [], ed;
        Y.Object.each(this._columnEditors,function(v,k){
            ed = (Y.Lang.isString(v)) ? this._commonEditors[v] : v;
            rtn.push({
                columnKey:      k,
                cellEditor:     ed,
                cellEditorName: ed.get(&#x27;name&#x27;)
            });
        },this);
        return rtn;
    },

    &#x2F;**
     * Returns the Column object (from the original &quot;columns&quot;) associated with the input TD Node.
     * @method getColumnByTd
     * @param {Node} cell Node of TD for which column object is desired
     * @return {Object} column The column object entry associated with the desired cell
     * @public
     *&#x2F;
    getColumnByTd:  function(cell){
        var colName = this.getColumnNameByTd(cell);
        return (colName) ? this.getColumn(colName) : null;
    },


    &#x2F;**
     * Returns the column &quot;key&quot; or &quot;name&quot; string for the requested TD Node
     * @method getColumnNameByTd
     * @param {Node} cell Node of TD for which column name is desired
     * @return {String} colName Column name or key name
     * @public
     *&#x2F;
    getColumnNameByTd: function(cell){
        var classes = cell.get(&#x27;className&#x27;).split(&quot; &quot;),
            regCol  = new RegExp( this.getClassName(&#x27;col&#x27;) + &#x27;-(.*)&#x27;),
            colName;

        Y.Array.some(classes,function(item){
            var colmatch =  item.match(regCol);
            if ( colmatch &amp;&amp; Y.Lang.isArray(colmatch) &amp;&amp; colmatch[1] ) {
                colName = colmatch[1];
                return true;
            }
        });

        return colName || null;
    },


&#x2F;&#x2F;==========================  PRIVATE METHODS  =============================

    &#x2F;**
     * Setter method for the [editable](#attr_editable) attribute for this DT
     * @method _setEditable
     * @param v {Boolean} Flag to enable&#x2F;disable editing mode for this DT instance
     * @private
     *&#x2F;
    _setEditable: function(v){
        if( v ) {
            &#x2F;&#x2F; call overrideable method .... simple return by default
            this.bindEditorListeners();
            this._bindCellEditingListeners();
            this._buildColumnEditors();

        } else  {
            &#x2F;&#x2F;if(this.get(&#x27;editable&#x27;)===true) {
                this._unbindCellEditingListeners();
                this._destroyColumnEditors();
            &#x2F;&#x2F;}
        }

    },

    &#x2F;**
     * Setter method for the [defaultEditor](#attr_defaultEditor) attribute for this DT
     * If the default editor is changed to a valid setting, we disable and re-enable
     * editing on the DT to reset the column editors.
     *
     * @method _setDefaultEditor
     * @param v {String|Null} Value to use for this attribute
     * @private
     *&#x2F;
    _setDefaultEditor: function(v) {
      &#x2F;&#x2F;  if ( (v &amp;&amp; Y.DataTable.EditorOptions[v]) || v === null) {
        if ( v  || v === null ) {
            if(this.get(&#x27;editable&#x27;)) {
                this.set(&#x27;editable&#x27;,false);
                this._set(&#x27;defaultEditor&#x27;,v);
                this.set(&#x27;editable&#x27;,true);
            }
        }
    },

    &#x2F;**
     * Setter method for the [editOpenType](#attr_editOpenType) attribute, specifies what
     * TD event to listen to for initiating editing.
     * @method _setEditOpenType
     * @param v {String}
     * @private
     *&#x2F;
    _setEditOpenType: function(v) {
        if(this._subscrCellEditors &amp;&amp; this._subscrCellEditors[0] &amp;&amp; this._subscrCellEditors[0].detach) {
            this.hideAllCellEditors();
            this._subscrCellEditors[0].detach();
            this._subscrCellEditors[0] = this.delegate( v, this.openCellEditor,&quot;tbody.&quot; + this.getClassName(&#x27;data&#x27;) + &quot; td&quot;,this);
        }
    },

    &#x2F;**
     * Pre-scans the DT columns looking for column named editors and collects unique editors,
     * instantiates them, and adds them to the  _columnEditors array.  This method only creates
     * View instances that are required, through combination of _commonEditors and _columnEditors
     * properties.
     *
     * @method _buildColumnEditors
     * @private
     *&#x2F;
    _buildColumnEditors: function(){
        var cols     = this.get(&#x27;columns&#x27;),
            defEditr = this.get(&#x27;defaultEditor&#x27;),
            edName, colKey, editorInstance;

        if( !Y.DataTable.EditorOptions ) {
            return;
        }

        if( this._columnEditors || this._commonEditors ) {
            this._destroyColumnEditors();
        }

        this._commonEditors = {};
        this._columnEditors = {};

        &#x2F;&#x2F;
        &#x2F;&#x2F;  Set the default editor, if one is defined
        &#x2F;&#x2F;
        defEditr = (defEditr &amp;&amp; defEditr.search(&#x2F;none|null&#x2F;i) !==0 ) ? defEditr : null;

        &#x2F;&#x2F;
        &#x2F;&#x2F;  Loop over all DT columns ....
        &#x2F;&#x2F;
        Y.Array.each(cols,function(c){
            if(!c) {
                return;
            }

            colKey = c.key || c.name;

            &#x2F;&#x2F; An editor was defined (in column) and doesn&#x27;t yet exist ...
            if(colKey &amp;&amp; c.editable !== false) {

                edName = c.editor || defEditr;

                &#x2F;&#x2F; This is an editable column, update the TD&#x27;s for the editable column
                this._updateEditableColumnCSS(colKey,true);

                &#x2F;&#x2F;this._editorColHash[colKey] = edName;

                &#x2F;&#x2F;
                &#x2F;&#x2F; If an editor is named, check if its definition exists, and that it is
                &#x2F;&#x2F; not already instantiated.   If not, create it ...
                &#x2F;&#x2F;

                &#x2F;&#x2F; check for common editor ....
                if (edName &amp;&amp; Y.DataTable.EditorOptions[edName]) {

                    if(c.editorConfig &amp;&amp; Y.Lang.isObject(c.editorConfig) ) {

                        editorInstance = this._createCellEditorInstance(edName,c);

                        this._columnEditors[colKey] = editorInstance || null;

                    } else {

                        if( !this._commonEditors[edName] ) {
                            editorInstance = this._createCellEditorInstance(edName,c);
                            this._commonEditors[edName] = editorInstance;
                        }

                        this._columnEditors[colKey] = edName;

                    }

                }

            }
        },this);

    },

    &#x2F;**
     * This method takes the given editorName (i.e. &#x27;textarea&#x27;) and if the default editor
     * configuration, adds in any column &#x27;editorConfig&#x27; and creates the corresponding
     * cell editor View instance.
     *
     * Makes shallow copies of editorConfig: { overlayConfig, widgetConfig, templateObject }
     *
     * @method _createCellEditorInstance
     * @param editorName {String} Editor name
     * @param column {Object} Column object
     * @return editorInstance {View} A newly created editor instance for the supplied editorname and column definitions
     * @private
     *&#x2F;
    _createCellEditorInstance: function(editorName, column) {
        var conf_obj      = Y.clone(Y.DataTable.EditorOptions[editorName],true),
            BaseViewClass = Y.DataTable.EditorOptions[editorName].BaseViewClass,
            editorInstance;

        if(column.editorConfig &amp;&amp; Y.Lang.isObject(column.editorConfig)) {
            conf_obj = Y.merge(conf_obj, column.editorConfig);

            if(column.editorConfig.overlayConfig) {
                conf_obj.overlayConfig = Y.merge(conf_obj.overlayConfig || {}, column.editorConfig.overlayConfig);
            }

            if(column.editorConfig.widgetConfig) {
                conf_obj.widgetConfig = Y.merge(conf_obj.widgetConfig || {}, column.editorConfig.widgetConfig);
            }

            if(column.editorConfig.templateObject) {
                conf_obj.templateObject = Y.merge(conf_obj.templateObject || {}, column.editorConfig.templateObject);
            }
            conf_obj.name = editorName;
        }

        delete conf_obj.BaseViewClass;

        &#x2F;&#x2F;
        &#x2F;&#x2F;  We have a valid base class, instantiate it
        &#x2F;&#x2F;
        if(BaseViewClass){
            conf_obj.hostDT = this;
            editorInstance = new BaseViewClass(conf_obj);

            &#x2F;&#x2F; make the one of this editor&#x27;s targets ...
            editorInstance.addTarget(this);
        }

        return editorInstance;
    },

    &#x2F;**
     * Loops through the column editor instances, destroying them and resetting the collection to null object
     * @method _destroyColumnEditors
     * @private
     *&#x2F;
    _destroyColumnEditors: function(){
        if( !this._columnEditors &amp;&amp; !this._commonEditors ) {
            return;
        }

        var ces = this._getAllCellEditors();
        Y.Array.each(ces,function(ce){
            if(ce &amp;&amp; ce.destroy) {
                ce.destroy();
              &#x2F;&#x2F;  ce.destroy({remove:true});
            }
        });

        this._commonEditors = null;
        this._columnEditors = null;

        &#x2F;&#x2F; remove editing class from all editable columns ...
        Y.Array.each( this.get(&#x27;columns&#x27;), function(c){
            if(c.editable === undefined || c.editable === true) {
                this._updateEditableColumnCSS(c.key || c.name,false);
            }
        },this);

    },

    &#x2F;**
     * Utility method to combine &quot;common&quot; and &quot;column-specific&quot; cell editor instances and return them
     * @method _getAllCellEditors
     * @return {Array} Of cell editor instances used for the current DT column configurations
     * @private
     *&#x2F;
    _getAllCellEditors: function() {
        var rtn = [];

        if( this._commonEditors ) {
            Y.Object.each(this._commonEditors,function(ce){
                if(ce &amp;&amp; ce instanceof Y.View){
                    rtn.push(ce);
                }
            });
        }

        if( this._columnEditors ) {
            Y.Object.each(this._columnEditors,function(ce){
                if(ce &amp;&amp; ce instanceof Y.View){
                    rtn.push(ce);
                }
            });
        }
        return rtn;
    },

    &#x2F;**
     * Closes the active cell editor when a document ESC key is detected
     * @method _onKeyEsc
     * @param e {EventFacade} key listener event facade
     * @private
     *&#x2F;
    _onKeyEsc:  function(e) {
        if(e.keyCode===27) {
            this.hideCellEditor();
        }
    },


    &#x2F;**
     * Listener to the &quot;sort&quot; event, so we can hide any open editors and update the editable column CSS
     *  after the UI refreshes
     * @method _afterEditableSort
     * @private
     *&#x2F;
    _afterEditableSort: function() {
        if(this.get(&#x27;editable&#x27;)) {
            this.hideCellEditor();
            this._updateAllEditableColumnsCSS();
        }
    },

    &#x2F;**
     * Re-initializes the static props to null
     * @method _unsetEditor
     * @private
     *&#x2F;
    _unsetEditor: function(){
        &#x2F;&#x2F; Finally, null out static props on this extension
        &#x2F;&#x2F;this._openEditor = null;
        this._openRecord = null;
        this._openColKey = null;
        this._openCell = null;
        this._openTd = null;
    },

    &#x2F;**
     * Method to update all of the current TD&#x27;s within the current DT to add&#x2F;remove the editable CSS
     * @method _updateAllEditableColumnsCSS
     * @private
     *&#x2F;
    _updateAllEditableColumnsCSS : function() {
        if(this.get(&#x27;editable&#x27;)) {
            var cols = this.get(&#x27;columns&#x27;),
                ckey;
            Y.Array.each(cols,function(col){
                ckey = col.key || col.name;
                if(ckey) {
                    this._updateEditableColumnCSS(ckey, true); &#x2F;&#x2F;(flag) ? col.editable || true : false);
                }
            },this);
        }
    },

    &#x2F;**
     * Method that adds&#x2F;removes the CSS editable-column class from a DataTable column,
     * based upon the setting of the boolean &quot;opt&quot;
     *
     * @method _updateEditableColumnCSS
     * @param cname {String}  Column key or name to alter
     * @param opt {Boolean} True of False to indicate if the CSS class should be added or removed
     * @private
     *&#x2F;
    _updateEditableColumnCSS : function(cname,opt) {
        var tbody = this.get(&#x27;contentBox&#x27;).one(&#x27;tbody.&#x27;+this.getClassName(&#x27;data&#x27;)),
            col   = (cname) ? this.getColumn(cname) : null,
            colEditable = col &amp;&amp; col.editable !== false,
            tdCol;
        if(!cname || !col) {
            return;
        }

        colEditable = (colEditable &amp;&amp; col.editor || (this.get(&#x27;defaultEditor&#x27;)!==null
            &amp;&amp; this.get(&#x27;defaultEditor&#x27;).search(&#x2F;none&#x2F;i)!==0) ) ? true : false;

        if(!tbody || !colEditable) {
            return;
        }

        tdCol = tbody.all(&#x27;td.&#x27;+this.getClassName(&#x27;col&#x27;,cname));

        if(tdCol &amp;&amp; opt===true) {
            tdCol.addClass(this._classColEditable);
        } else if (tdCol) {
            tdCol.removeClass(this._classColEditable);
        }
    },

    &#x2F;**
     * Listener to TD &quot;click&quot; events that hides a popup editor is not in the current cell
     * @method _handleCellClick
     * @param e
     * @private
     *&#x2F;
    _handleCellClick:  function(e){
        var td = e.currentTarget,
            cn = this.getColumnNameByTd(td);
        if (cn &amp;&amp; this._openEditor &amp;&amp;  this._openEditor.get(&#x27;colKey&#x27;)!==cn) {
            this.hideCellEditor();
        }
    },

    &#x2F;**
     * Listener that fires on a scrollable DT scrollbar &quot;scroll&quot; event, and updates the current XY position
     *  of the currently open Editor.
     *
     * @method _onScrollUpdateCellEditor
     * @private
     *&#x2F;
    _onScrollUpdateCellEditor: function(e) {
        &#x2F;&#x2F;
        &#x2F;&#x2F;  Only go into this dark realm if we have a TD and an editor is open ...
        &#x2F;&#x2F;
        if(this.get(&#x27;editable&#x27;) &amp;&amp; this.get(&#x27;scrollable&#x27;) &amp;&amp; this._openEditor &amp;&amp; this._openTd ) {

           var tar    = e.target,
               tarcl  = tar.get(&#x27;className&#x27;) || &#x27;&#x27;,
               tr1    = this.getRow(0),
               trh    = (tr1) ? +tr1.getComputedStyle(&#x27;height&#x27;).replace(&#x2F;px&#x2F;,&#x27;&#x27;) : 0,
               tdxy   = (this._openTd) ? this._openTd.getXY() : null,
               xmin, xmax, ymin, ymax, hidef;

            &#x2F;&#x2F;
            &#x2F;&#x2F; For vertical scrolling - check vertical &#x27;y&#x27; limits
            &#x2F;&#x2F;
            if( tarcl.search(&#x2F;-y-&#x2F;) !==-1 ) {

                ymin = this._yScrollNode.getY() + trh - 5;
                ymax = ymin + (+this._yScrollNode.getComputedStyle(&#x27;height&#x27;).replace(&#x2F;px&#x2F;,&#x27;&#x27;)) - 2*trh;

                if(tdxy[1] &gt;= ymin &amp;&amp; tdxy[1] &lt;= ymax ) {
                    if(this._openEditor.get(&#x27;hidden&#x27;)) {
                        this._openEditor.showEditor(this._openTd);
                    } else {
                        this._openEditor.set(&#x27;xy&#x27;, tdxy );
                    }
                } else {
                    hidef = true;
                }
            }

            &#x2F;&#x2F;
            &#x2F;&#x2F; For horizontal scrolling - check horizontal &#x27;x&#x27; limits
            &#x2F;&#x2F;
            if( tarcl.search(&#x2F;-x-&#x2F;) !==-1 ) {

                xmin = this._xScrollNode.getX();
                xmax = xmin + (+this._xScrollNode.getComputedStyle(&#x27;width&#x27;).replace(&#x2F;px&#x2F;,&#x27;&#x27;));
                xmax -= +this._openTd.getComputedStyle(&#x27;width&#x27;).replace(&#x2F;px&#x2F;,&#x27;&#x27;);

                if(tdxy[0] &gt;= xmin &amp;&amp; tdxy[0] &lt;= xmax ) {
                    if(this._openEditor.get(&#x27;hidden&#x27;)) {
                        this._openEditor.showEditor(this._openTd);
                    } else {
                        this._openEditor.set(&#x27;xy&#x27;, tdxy );
                    }
                } else {
                    hidef = true;
                }
            }

            &#x2F;&#x2F; If hidef is true, editor is out of view, hide it temporarily
            if(hidef) {
                this._openEditor.hideEditor(true);
            }

        }
    },

    &#x2F;**
     * Listens to changes to an Editor&#x27;s &quot;keyDir&quot; event, which result from the user
     * pressing &quot;ctrl-&quot; arrow key while in an editor to navigate to an cell.
     *
     * The value of &quot;keyDir&quot; is an Array of two elements, in [row,col] format which indicates
     * the number of rows or columns to be changed to from the current TD location
     * (See the base method .getCell)
     *
     * @method _onKeyDirChange
     * @param e {EventFacade} The attribute change event facade for the View&#x27;s &#x27;keyDir&#x27; attribute
     * @private
     *&#x2F;
    _onKeyDirChange : function(e) {
        var dir     = e.newVal,
            recIndex = this.data.indexOf(this._openRecord),
            col      = this.getColumn(this._openColKey),
            colIndex = Y.Array.indexOf(this.get(&#x27;columns&#x27;),col),
            oldTd    = this._openTd,
            newTd, ndir, circ;

       this.hideCellEditor();

       &#x2F;&#x2F;TODO: Implement &quot;circular&quot; mode, maybe thru an attribute to wrap col&#x2F;row navigation
       if(circ) {

           if(dir[1] === 1 &amp;&amp; colIndex === this.get(&#x27;columns&#x27;).length-1 ) {
               ndir = [0, -this.get(&#x27;columns&#x27;).length+1];
           } else if(dir[1] === -1 &amp;&amp; colIndex === 0) {
               ndir = [0, this.get(&#x27;columns&#x27;).length-1];
           } else if(dir[0] === 1 &amp;&amp; recIndex === this.data.size()-1 ) {
               ndir = [ -this.data.size()+1, 0];
           } else if(dir[0] === -1 &amp;&amp; recIndex === 0) {
               ndir = [ this.data.size()-1, 0];
           }

           if(ndir) {
               dir = ndir;
           }

       }

       if(dir){
           newTd = this.getCell(oldTd, dir);
           if(newTd) {
               this.openCellEditor(newTd);
           }
       }
    },

    &#x2F;**
     * Listener to the cell editor View&#x27;s &quot;editorCancel&quot; event.  The editorCancel event
     * includes a return object with keys {td,cell,oldValue}
     *
     * @method _onCellEditorCancel
     * @param o {Object} Returned object from cell editor &quot;editorCancel&quot; event
     * @private
     *&#x2F;
    _onCellEditorCancel: function(o){
        if(o.cell &amp;&amp; this._openRecord &amp;&amp; this._openColKey) {
            var cell   = o.cell,
                colKey = cell.colKey || this._openColKey,
                record = this.data.getByClientId(cell.recClientId) || this._openRecord,
                ename  = this._openEditor.get(&#x27;name&#x27;);

            if(!this._openEditor.get(&#x27;hidden&#x27;)) {
                this.hideCellEditor();
            }

            this.fire(&#x27;cellEditorCancel&#x27;,{
                td:         o.td,
                cell:       cell,
                record:     record,
                colKey:     colKey,
                prevVal:    o.oldValue,
                editorName: ename
            });
        }

    },

    &#x2F;**
     * Fired when the open Cell Editor has sent an &#x27;editorCancel&#x27; event, typically from
     * a user cancelling editing via ESC key or &quot;Cancel Button&quot;
     * @event cellEditorCancel
     * @param {Object} rtn Returned Object
     *  @param {Node} td The TD Node that was edited
     *  @param {Object} cell The cell object container for the edited cell
     *  @param {Model} record Model instance of the record data for the edited cell
     *  @param {String} colKey Column key (or name) of the edited cell
     *  @param {String|Number|Date} newVal The old (last) value of the underlying data for the cell
     *  @param {String} editorName The name attribute of the editor that updated this cell
     *&#x2F;

    &#x2F;**
     * Listener to the cell editor View&#x27;s &quot;editorSave&quot; event, that when fired will
     * update the Model&#x27;s data value for the approrpriate column.
     *
     * The editorSave event includes a return object with keys {td,cell,newValue,oldValue}
     *
     * Note:  If a &quot;sync&quot; layer DOES NOT exist (i.e. DataSource), implementers can listen for
     * the &quot;saveCellEditing&quot; event to send changes to a remote data store.
     *
     * @method _onCellEditorSave
     * @param o {Object} Returned object from cell editor &quot;editorSave&quot; event
     * @private
     *&#x2F;
    _onCellEditorSave: function(o){
        if(o.cell &amp;&amp; this._openRecord &amp;&amp; this._openColKey) {
            var cell   = o.cell,
                colKey = cell.colKey || this._openColKey,
                record = this.data.getByClientId(cell.recClientId) || this._openRecord,
                ename  = this._openEditor.get(&#x27;name&#x27;);

            if(record){
                record.set(this._openColKey, o.newValue);
            }

            this.hideCellEditor();

            this.fire(&#x27;cellEditorSave&#x27;,{
                td:         o.td,
                cell:       cell,
                record:     record,
                colKey:     colKey,
                newVal:     o.newValue,
                prevVal:    o.oldValue,
                editorName: ename
            });

        }

    }

    &#x2F;**
     * Event fired after a Cell Editor has sent the &#x27;editorSave&#x27; event closing an editing session.
     * The event signature includes pertinent data on the cell, TD, record and column that was
     * edited along with the prior and new values for the cell.
     * @event cellEditorSave
     * @param {Object} rtn Returned Object
     *  @param {Node} td The TD Node that was edited
     *  @param {Object} cell The cell object container for the edited cell
     *  @param {Model} record Model instance of the record data for the edited cell
     *  @param {String} colKey Column key (or name) of the edited cell
     *  @param {String|Number|Date} newVal The new (updated) value of the underlying data for the cell
     *  @param {String|Number|Date} newVal The old (last) value of the underlying data for the cell
     *  @param {String} editorName The name attribute of the editor that updated this cell
     *&#x2F;

});

Y.DataTable.Editable = DtEditable;
Y.Base.mix(Y.DataTable, [Y.DataTable.Editable]);

&#x2F;**
 * This object is attached to the DataTable namespace to allow addition of &quot;editors&quot; in conjunction
 * with the Y.DataTable.Editable module.
 *
 * (See modules gallery-datatable-celleditor-popup and gallery-datatable-celleditor-inline for
 *  examples of the content of this object)
 *
 * @class Y.DataTable.EditorOptions
 * @extends Y.DataTable
 * @type {Object}
 * @since 3.8.0
 *&#x2F;
Y.DataTable.EditorOptions = {};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
